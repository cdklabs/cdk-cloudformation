// Generated by cdk-import
import * as cdk from 'aws-cdk-lib';
import * as constructs from 'constructs';

/**
 * The Workflows app is a powerful tool that lets you automatically act on monitoring data
 *
 * @schema CfnWorkflowProps
 */
export interface CfnWorkflowProps {
  /**
   * The user context the executions of the workflow will happen with
   *
   * @schema CfnWorkflowProps#Actor
   */
  readonly actor?: string;

  /**
   * An optional description for the workflow
   *
   * @schema CfnWorkflowProps#Description
   */
  readonly description?: string;

  /**
   * Defines whether this workflow is private to the owner or not
   *
   * @schema CfnWorkflowProps#IsPrivate
   */
  readonly isPrivate?: boolean;

  /**
   * The ID of the owner of this workflow
   *
   * @schema CfnWorkflowProps#Owner
   */
  readonly owner?: string;

  /**
   * The tasks to run for every execution of this workflow
   *
   * @schema CfnWorkflowProps#Tasks
   */
  readonly tasks: Task[];

  /**
   * @schema CfnWorkflowProps#Throttle
   */
  readonly throttle?: ThrottleRequest;

  /**
   * The title / name of the workflow
   *
   * @schema CfnWorkflowProps#Title
   */
  readonly title: string;

  /**
   * @schema CfnWorkflowProps#Trigger
   */
  readonly trigger?: TriggerRequest;

}

/**
 * Converts an object of type 'CfnWorkflowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnWorkflowProps(obj: CfnWorkflowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Actor': obj.actor,
    'Description': obj.description,
    'IsPrivate': obj.isPrivate,
    'Owner': obj.owner,
    'Tasks': obj.tasks?.map(y => toJson_Task(y)),
    'Throttle': toJson_ThrottleRequest(obj.throttle),
    'Title': obj.title,
    'Trigger': toJson_TriggerRequest(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Task
 */
export interface Task {
  /**
   * Currently known and supported values are dynatrace.automations:http-function, dynatrace.automations:run-javascript and dynatrace.automations:execute-dql-query
   *
   * @schema Task#Action
   */
  readonly action: TaskAction;

  /**
   * Specifies whether a task should be skipped as a no operation or not
   *
   * @schema Task#Active
   */
  readonly active?: boolean;

  /**
   * Required if 'WithItems' is specified. By default loops execute sequentially with concurrency set to 1. You can increase how often it runs in parallel
   *
   * @schema Task#Concurrency
   */
  readonly concurrency?: number;

  /**
   * @schema Task#Condition
   */
  readonly condition?: Condition;

  /**
   * A description for this task
   *
   * @schema Task#Description
   */
  readonly description?: string;

  /**
   * @schema Task#Input
   */
  readonly input?: any;

  /**
   * The name of the task
   *
   * @schema Task#Name
   */
  readonly name: string;

  /**
   * @schema Task#Position
   */
  readonly position?: Position;

  /**
   * @schema Task#Retry
   */
  readonly retry?: Retry;

  /**
   * Specifies a default task timeout in seconds. 15 * 60 (15min) is used when not set.
   *
   * @schema Task#Timeout
   */
  readonly timeout?: number;

  /**
   * Iterates over items in a list, allowing actions to be executed repeatedly. Example: Specifying item in [1, 2, 3] here will execute the task three times for the numbers 1, 2 and 3 - with the current number available for scripting using the expression {{ _.item }}
   *
   * @schema Task#WithItems
   */
  readonly withItems?: string;

}

/**
 * Converts an object of type 'Task' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Task(obj: Task | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Action': obj.action,
    'Active': obj.active,
    'Concurrency': obj.concurrency,
    'Condition': toJson_Condition(obj.condition),
    'Description': obj.description,
    'Input': obj.input,
    'Name': obj.name,
    'Position': toJson_Position(obj.position),
    'Retry': toJson_Retry(obj.retry),
    'Timeout': obj.timeout,
    'WithItems': obj.withItems,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThrottleRequest
 */
export interface ThrottleRequest {
  /**
   * @schema ThrottleRequest#IsLimitHit
   */
  readonly isLimitHit: boolean;

  /**
   * @schema ThrottleRequest#LimitEvents
   */
  readonly limitEvents?: ThrottleLimitEvent[];

}

/**
 * Converts an object of type 'ThrottleRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThrottleRequest(obj: ThrottleRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'IsLimitHit': obj.isLimitHit,
    'LimitEvents': obj.limitEvents?.map(y => toJson_ThrottleLimitEvent(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how executions of the workflows are getting triggered. If no trigger is specified it means the workflow is getting manually triggered
 *
 * @schema TriggerRequest
 */
export interface TriggerRequest {
  /**
   * @schema TriggerRequest#EventTrigger
   */
  readonly eventTrigger?: EventTriggerRequest;

  /**
   * @schema TriggerRequest#Schedule
   */
  readonly schedule?: ScheduleRequest;

}

/**
 * Converts an object of type 'TriggerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerRequest(obj: TriggerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'EventTrigger': toJson_EventTriggerRequest(obj.eventTrigger),
    'Schedule': toJson_ScheduleRequest(obj.schedule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Currently known and supported values are dynatrace.automations:http-function, dynatrace.automations:run-javascript and dynatrace.automations:execute-dql-query
 *
 * @schema TaskAction
 */
export enum TaskAction {
  /** dynatrace.automations:http-function */
  DYNATRACE_PERIOD_AUTOMATIONS_HTTP_HYPHEN_FUNCTION = "dynatrace.automations:http-function",
  /** dynatrace.automations:run-javascript */
  DYNATRACE_PERIOD_AUTOMATIONS_RUN_HYPHEN_JAVASCRIPT = "dynatrace.automations:run-javascript",
  /** dynatrace.automations:execute-dql-query */
  DYNATRACE_PERIOD_AUTOMATIONS_EXECUTE_HYPHEN_DQL_HYPHEN_QUERY = "dynatrace.automations:execute-dql-query",
  /** dynatrace.site.reliability.guardian:validate-guardian-action */
  DYNATRACE_PERIOD_SITE_PERIOD_RELIABILITY_PERIOD_GUARDIAN_VALIDATE_HYPHEN_GUARDIAN_HYPHEN_ACTION = "dynatrace.site.reliability.guardian:validate-guardian-action",
}

/**
 * @schema Condition
 */
export interface Condition {
  /**
   * A custom condition that needs to be met for the current task to get executed
   *
   * @schema Condition#Custom
   */
  readonly custom?: string;

  /**
   * Possible values are SKIP and STOP
   *
   * @schema Condition#Else
   */
  readonly else?: ConditionElse;

  /**
   * key/value pairs where the key is the name of another task and the value the status it needs to be for the current task to get executed. Possible values are SUCCESS, ERROR, ANY, OK (Success or Skipped) and NOK (Error or Cancelled)
   *
   * @schema Condition#States
   */
  readonly states: any;

}

/**
 * Converts an object of type 'Condition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Condition(obj: Condition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Custom': obj.custom,
    'Else': obj.else,
    'States': obj.states,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Layouting information about the task tile when visualized. If not specified Dynatrace will position the task tiles automatically
 *
 * @schema Position
 */
export interface Position {
  /**
   * x-coordinate for layouting
   *
   * @schema Position#X
   */
  readonly x: number;

  /**
   * y-coordinate for layouting
   *
   * @schema Position#Y
   */
  readonly y: number;

}

/**
 * Converts an object of type 'Position' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Position(obj: Position | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'X': obj.x,
    'Y': obj.y,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure whether to automatically rerun the task on failure. If not specified no retries will be attempted
 *
 * @schema Retry
 */
export interface Retry {
  /**
   * Specifies a maximum number of times that a task can be repeated in case it fails on execution. You can specify either a number between 1 and 99 here or use an expression
   *
   * @schema Retry#Count
   */
  readonly count?: string;

  /**
   * Specifies a delay in seconds between subsequent task retries. You can specify either a number between 1 and 3600 here or an expression ({{...}})
   *
   * @schema Retry#Delay
   */
  readonly delay?: string;

  /**
   * Specifies whether retrying the failed iterations or the whole loop
   *
   * @schema Retry#FailedLoopIterationsOnly
   */
  readonly failedLoopIterationsOnly?: boolean;

}

/**
 * Converts an object of type 'Retry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Retry(obj: Retry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Count': obj.count,
    'Delay': obj.delay,
    'FailedLoopIterationsOnly': obj.failedLoopIterationsOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThrottleLimitEvent
 */
export interface ThrottleLimitEvent {
  /**
   * @schema ThrottleLimitEvent#Limit
   */
  readonly limit: number;

  /**
   * @schema ThrottleLimitEvent#TimeLeftInSeconds
   */
  readonly timeLeftInSeconds: number;

  /**
   * @schema ThrottleLimitEvent#Timestamp
   */
  readonly timestamp: Date;

}

/**
 * Converts an object of type 'ThrottleLimitEvent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThrottleLimitEvent(obj: ThrottleLimitEvent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Limit': obj.limit,
    'TimeLeftInSeconds': obj.timeLeftInSeconds,
    'Timestamp': obj.timestamp?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventTriggerRequest
 */
export interface EventTriggerRequest {
  /**
   * If specified the workflow is getting triggered based on a schedule
   *
   * @schema EventTriggerRequest#IsActive
   */
  readonly isActive?: boolean;

  /**
   * @schema EventTriggerRequest#TriggerConfiguration
   */
  readonly triggerConfiguration?: EventTriggerRequestTriggerConfiguration;

}

/**
 * Converts an object of type 'EventTriggerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventTriggerRequest(obj: EventTriggerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'IsActive': obj.isActive,
    'TriggerConfiguration': toJson_EventTriggerRequestTriggerConfiguration(obj.triggerConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleRequest
 */
export interface ScheduleRequest {
  /**
   * @schema ScheduleRequest#FilterParameters
   */
  readonly filterParameters?: ScheduleFilterParameters;

  /**
   * @schema ScheduleRequest#Input
   */
  readonly input?: any;

  /**
   * @schema ScheduleRequest#IsActive
   */
  readonly isActive?: boolean;

  /**
   * @schema ScheduleRequest#NextExecution
   */
  readonly nextExecution?: Date;

  /**
   * @schema ScheduleRequest#Rule
   */
  readonly rule?: string;

  /**
   * Timezone identifier, e.g. Europe/London
   *
   * @schema ScheduleRequest#Timezone
   */
  readonly timezone?: string;

  /**
   * @schema ScheduleRequest#Trigger
   */
  readonly trigger: any;

}

/**
 * Converts an object of type 'ScheduleRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleRequest(obj: ScheduleRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'FilterParameters': toJson_ScheduleFilterParameters(obj.filterParameters),
    'Input': obj.input,
    'IsActive': obj.isActive,
    'NextExecution': obj.nextExecution?.toISOString(),
    'Rule': obj.rule,
    'Timezone': obj.timezone,
    'Trigger': obj.trigger,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Possible values are SKIP and STOP
 *
 * @schema ConditionElse
 */
export enum ConditionElse {
  /** SKIP */
  SKIP = "SKIP",
  /** STOP */
  STOP = "STOP",
}

/**
 * @schema EventTriggerRequestTriggerConfiguration
 */
export interface EventTriggerRequestTriggerConfiguration {
  /**
   * @schema EventTriggerRequestTriggerConfiguration#Type
   */
  readonly type?: EventTriggerRequestTriggerConfigurationType;

  /**
   * @schema EventTriggerRequestTriggerConfiguration#Value
   */
  readonly value?: EventTriggerConfig;

}

/**
 * Converts an object of type 'EventTriggerRequestTriggerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventTriggerRequestTriggerConfiguration(obj: EventTriggerRequestTriggerConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Type': obj.type,
    'Value': toJson_EventTriggerConfig(obj.value),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleFilterParameters
 */
export interface ScheduleFilterParameters {
  /**
   * @schema ScheduleFilterParameters#Count
   */
  readonly count?: number;

  /**
   * @schema ScheduleFilterParameters#EarliestStart
   */
  readonly earliestStart?: Date;

  /**
   * @schema ScheduleFilterParameters#EarliestStartTime
   */
  readonly earliestStartTime?: string;

  /**
   * @schema ScheduleFilterParameters#ExcludeDates
   */
  readonly excludeDates?: Date[];

  /**
   * @schema ScheduleFilterParameters#IncludeDates
   */
  readonly includeDates?: Date[];

  /**
   * @schema ScheduleFilterParameters#Until
   */
  readonly until?: Date;

}

/**
 * Converts an object of type 'ScheduleFilterParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleFilterParameters(obj: ScheduleFilterParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Count': obj.count,
    'EarliestStart': obj.earliestStart?.toISOString(),
    'EarliestStartTime': obj.earliestStartTime,
    'ExcludeDates': obj.excludeDates?.map(y => y?.toISOString()),
    'IncludeDates': obj.includeDates?.map(y => y?.toISOString()),
    'Until': obj.until?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventTriggerRequestTriggerConfigurationType
 */
export enum EventTriggerRequestTriggerConfigurationType {
  /** davis-event */
  DAVIS_HYPHEN_EVENT = "davis-event",
  /** davis-problem */
  DAVIS_HYPHEN_PROBLEM = "davis-problem",
  /** event */
  EVENT = "event",
}

/**
 * If specified the workflow is getting triggered based on events
 *
 * @schema EventTriggerConfig
 */
export interface EventTriggerConfig {
  /**
   * @schema EventTriggerConfig#Names
   */
  readonly names?: DavisEventName[];

  /**
   * @schema EventTriggerConfig#Categories
   */
  readonly categories?: DavisProblemCategories;

  /**
   * @schema EventTriggerConfig#CustomFilters
   */
  readonly customFilters?: string;

  /**
   * @schema EventTriggerConfig#EntityTags
   */
  readonly entityTags?: any;

  /**
   * @schema EventTriggerConfig#EntityTagsMatch
   */
  readonly entityTagsMatch?: EventTriggerConfigEntityTagsMatch;

  /**
   * @schema EventTriggerConfig#OnProblemClose
   */
  readonly onProblemClose?: boolean;

  /**
   * @schema EventTriggerConfig#EventType
   */
  readonly eventType?: EventTriggerConfigEventType;

  /**
   * @schema EventTriggerConfig#Query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'EventTriggerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventTriggerConfig(obj: EventTriggerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Names': obj.names?.map(y => toJson_DavisEventName(y)),
    'Categories': toJson_DavisProblemCategories(obj.categories),
    'CustomFilters': obj.customFilters,
    'EntityTags': obj.entityTags,
    'EntityTagsMatch': obj.entityTagsMatch,
    'OnProblemClose': obj.onProblemClose,
    'EventType': obj.eventType,
    'Query': obj.query,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DavisEventName
 */
export interface DavisEventName {
  /**
   * @schema DavisEventName#Match
   */
  readonly match: DavisEventNameMatch;

  /**
   * @schema DavisEventName#Name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DavisEventName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DavisEventName(obj: DavisEventName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Match': obj.match,
    'Name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DavisProblemCategories
 */
export interface DavisProblemCategories {
  /**
   * @schema DavisProblemCategories#Availability
   */
  readonly availability?: boolean;

  /**
   * @schema DavisProblemCategories#Custom
   */
  readonly custom?: boolean;

  /**
   * @schema DavisProblemCategories#Error
   */
  readonly error?: boolean;

  /**
   * @schema DavisProblemCategories#Info
   */
  readonly info?: boolean;

  /**
   * @schema DavisProblemCategories#MonitoringUnavailable
   */
  readonly monitoringUnavailable?: boolean;

  /**
   * @schema DavisProblemCategories#Resource
   */
  readonly resource?: boolean;

  /**
   * @schema DavisProblemCategories#Slowdown
   */
  readonly slowdown?: boolean;

}

/**
 * Converts an object of type 'DavisProblemCategories' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DavisProblemCategories(obj: DavisProblemCategories | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Availability': obj.availability,
    'Custom': obj.custom,
    'Error': obj.error,
    'Info': obj.info,
    'MonitoringUnavailable': obj.monitoringUnavailable,
    'Resource': obj.resource,
    'Slowdown': obj.slowdown,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventTriggerConfigEntityTagsMatch
 */
export enum EventTriggerConfigEntityTagsMatch {
  /** All */
  ALL = "All",
  /** Any */
  ANY = "Any",
}

/**
 * @schema EventTriggerConfigEventType
 */
export enum EventTriggerConfigEventType {
  /** bizevents */
  BIZEVENTS = "bizevents",
  /** events */
  EVENTS = "events",
}

/**
 * @schema DavisEventNameMatch
 */
export enum DavisEventNameMatch {
  /** Contains */
  CONTAINS = "Contains",
  /** Equals */
  EQUALS = "Equals",
}


/**
 * A CloudFormation `Dynatrace::Automation::Workflow`
 *
 * @cloudformationResource Dynatrace::Automation::Workflow
 * @stability external
 * @link https://docs.dynatrace.com/docs/platform-modules/automations/workflows
 */
export class CfnWorkflow extends cdk.CfnResource {
  /**
  * The CloudFormation resource type name for this resource class.
  */
  public static readonly CFN_RESOURCE_TYPE_NAME = "Dynatrace::Automation::Workflow";

  /**
   * Resource props.
   */
  public readonly props: CfnWorkflowProps;

  /**
   * Attribute `Dynatrace::Automation::Workflow.Id`
   * @link https://docs.dynatrace.com/docs/platform-modules/automations/workflows
   */
  public readonly attrId: string;
  /**
   * Attribute `Dynatrace::Automation::Workflow.OwnerType`
   * @link https://docs.dynatrace.com/docs/platform-modules/automations/workflows
   */
  public readonly attrOwnerType: string;
  /**
   * Attribute `Dynatrace::Automation::Workflow.SchemaVersion`
   * @link https://docs.dynatrace.com/docs/platform-modules/automations/workflows
   */
  public readonly attrSchemaVersion: number;

  /**
   * Create a new `Dynatrace::Automation::Workflow`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(scope: constructs.Construct, id: string, props: CfnWorkflowProps) {
    super(scope, id, { type: CfnWorkflow.CFN_RESOURCE_TYPE_NAME, properties: toJson_CfnWorkflowProps(props)! });

    this.props = props;

    this.attrId = cdk.Token.asString(this.getAtt('Id'));
    this.attrOwnerType = cdk.Token.asString(this.getAtt('OwnerType'));
    this.attrSchemaVersion = cdk.Token.asNumber(this.getAtt('SchemaVersion'));
  }
}