// Generated by cdk-import
import * as cdk from 'aws-cdk-lib';
import * as constructs from 'constructs';

/**
 * Returns, adds, edits, and removes Federated Database Instances.
 *
 * @schema CfnDataLakesProps
 */
export interface CfnDataLakesProps {
  /**
   * @schema CfnDataLakesProps#ApiKeys
   */
  readonly apiKeys?: ApiKeyDefinition;

  /**
   * Cloud provider linked to this data lake.
   *
   * @schema CfnDataLakesProps#CloudProviderConfig
   */
  readonly cloudProviderConfig?: DataLakeCloudProviderConfigView;

  /**
   * Information about the cloud provider region to which the data lake routes client connections. MongoDB Cloud supports AWS only.
   *
   * @schema CfnDataLakesProps#DataProcessRegion
   */
  readonly dataProcessRegion?: DataLakeDataProcessRegionView;

  /**
   * Configuration information for each data store and its mapping to MongoDB Cloud databases.
   *
   * @schema CfnDataLakesProps#Storage
   */
  readonly storage?: DataLakeStorageView;

}

/**
 * Converts an object of type 'CfnDataLakesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnDataLakesProps(obj: CfnDataLakesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ApiKeys': toJson_ApiKeyDefinition(obj.apiKeys),
    'CloudProviderConfig': toJson_DataLakeCloudProviderConfigView(obj.cloudProviderConfig),
    'DataProcessRegion': toJson_DataLakeDataProcessRegionView(obj.dataProcessRegion),
    'Storage': toJson_DataLakeStorageView(obj.storage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema apiKeyDefinition
 */
export interface ApiKeyDefinition {
  /**
   * @schema apiKeyDefinition#PrivateKey
   */
  readonly privateKey?: string;

  /**
   * @schema apiKeyDefinition#PublicKey
   */
  readonly publicKey?: string;

}

/**
 * Converts an object of type 'ApiKeyDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeyDefinition(obj: ApiKeyDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'PrivateKey': obj.privateKey,
    'PublicKey': obj.publicKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeCloudProviderConfigView
 */
export interface DataLakeCloudProviderConfigView {
  /**
   * Name of the cloud service that hosts the data lake's data stores.
   *
   * @schema DataLakeCloudProviderConfigView#Aws
   */
  readonly aws?: DataLakeAwsCloudProviderConfigView;

}

/**
 * Converts an object of type 'DataLakeCloudProviderConfigView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeCloudProviderConfigView(obj: DataLakeCloudProviderConfigView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Aws': toJson_DataLakeAwsCloudProviderConfigView(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeDataProcessRegionView
 */
export interface DataLakeDataProcessRegionView {
  /**
   * Name of the cloud service that hosts the data lake's data stores.
   *
   * @schema DataLakeDataProcessRegionView#CloudProvider
   */
  readonly cloudProvider?: DataLakeDataProcessRegionViewCloudProvider;

  /**
   * Name of the region to which the data lake routes client connections.
   *
   * @schema DataLakeDataProcessRegionView#Region
   */
  readonly region?: DataLakeDataProcessRegionViewRegion;

}

/**
 * Converts an object of type 'DataLakeDataProcessRegionView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeDataProcessRegionView(obj: DataLakeDataProcessRegionView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CloudProvider': obj.cloudProvider,
    'Region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeStorageView
 */
export interface DataLakeStorageView {
  /**
   * Array that contains the queryable databases and collections for this data lake.
   *
   * @schema DataLakeStorageView#Databases
   */
  readonly databases?: DataLakeDatabaseView[];

  /**
   * Array that contains the data stores for the data lake.
   *
   * @schema DataLakeStorageView#Stores
   */
  readonly stores?: StoreDetail[];

}

/**
 * Converts an object of type 'DataLakeStorageView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeStorageView(obj: DataLakeStorageView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Databases': obj.databases?.map(y => toJson_DataLakeDatabaseView(y)),
    'Stores': obj.stores?.map(y => toJson_StoreDetail(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeAWSCloudProviderConfigView
 */
export interface DataLakeAwsCloudProviderConfigView {
  /**
   * Unique identifier associated with the Identity and Access Management (IAM) role that the data lake assumes when accessing the data stores.
   *
   * @schema DataLakeAWSCloudProviderConfigView#ExternalId
   */
  readonly externalId?: string;

  /**
   * Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the data lake assumes when accessing data stores.
   *
   * @schema DataLakeAWSCloudProviderConfigView#IamAssumedRoleARN
   */
  readonly iamAssumedRoleArn?: string;

  /**
   * Amazon Resource Name (ARN) of the user that the data lake assumes when accessing data stores.
   *
   * @schema DataLakeAWSCloudProviderConfigView#IamUserARN
   */
  readonly iamUserArn?: string;

  /**
   * Unique identifier of the role that the data lake can use to access the data stores.Required if specifying cloudProviderConfig.
   *
   * @schema DataLakeAWSCloudProviderConfigView#RoleId
   */
  readonly roleId?: string;

  /**
   * Name of the S3 data bucket that the provided role ID is authorized to access.Required if specifying cloudProviderConfig.
   *
   * @schema DataLakeAWSCloudProviderConfigView#TestS3Bucket
   */
  readonly testS3Bucket?: string;

}

/**
 * Converts an object of type 'DataLakeAwsCloudProviderConfigView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeAwsCloudProviderConfigView(obj: DataLakeAwsCloudProviderConfigView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ExternalId': obj.externalId,
    'IamAssumedRoleARN': obj.iamAssumedRoleArn,
    'IamUserARN': obj.iamUserArn,
    'RoleId': obj.roleId,
    'TestS3Bucket': obj.testS3Bucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name of the cloud service that hosts the data lake's data stores.
 *
 * @schema DataLakeDataProcessRegionViewCloudProvider
 */
export enum DataLakeDataProcessRegionViewCloudProvider {
  /** AWS */
  AWS = "AWS",
  /** GCP */
  GCP = "GCP",
  /** AZURE */
  AZURE = "AZURE",
  /** TENANT */
  TENANT = "TENANT",
  /** SERVERLESS */
  SERVERLESS = "SERVERLESS",
}

/**
 * Name of the region to which the data lake routes client connections.
 *
 * @schema DataLakeDataProcessRegionViewRegion
 */
export enum DataLakeDataProcessRegionViewRegion {
  /** DUBLIN_IRL */
  DUBLIN_IRL = "DUBLIN_IRL",
  /** FRANKFURT_DEU */
  FRANKFURT_DEU = "FRANKFURT_DEU",
  /** LONDON_GBR */
  LONDON_GBR = "LONDON_GBR",
  /** MUMBAI_IND */
  MUMBAI_IND = "MUMBAI_IND",
  /** OREGON_USA */
  OREGON_USA = "OREGON_USA",
  /** SYDNEY_AUS */
  SYDNEY_AUS = "SYDNEY_AUS",
  /** VIRGINIA_USA */
  VIRGINIA_USA = "VIRGINIA_USA",
}

/**
 * @schema DataLakeDatabaseView
 */
export interface DataLakeDatabaseView {
  /**
   * Array of collections and data sources that map to a ``stores`` data store.
   *
   * @schema DataLakeDatabaseView#Collections
   */
  readonly collections?: DataLakeDatabaseCollectionView[];

  /**
   * Maximum number of wildcard collections in the database. This only applies to S3 data sources.
   *
   * @schema DataLakeDatabaseView#MaxWildcardCollections
   */
  readonly maxWildcardCollections?: number;

  /**
   * Human-readable label that identifies the database to which the data lake maps data.
   *
   * @schema DataLakeDatabaseView#Name
   */
  readonly name?: string;

  /**
   * Array of aggregation pipelines that apply to the collection. This only applies to S3 data sources.
   *
   * @schema DataLakeDatabaseView#Views
   */
  readonly views?: DataLakeViewView[];

}

/**
 * Converts an object of type 'DataLakeDatabaseView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeDatabaseView(obj: DataLakeDatabaseView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Collections': obj.collections?.map(y => toJson_DataLakeDatabaseCollectionView(y)),
    'MaxWildcardCollections': obj.maxWildcardCollections,
    'Name': obj.name,
    'Views': obj.views?.map(y => toJson_DataLakeViewView(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration information for each data store and its mapping to MongoDB Cloud databases.
 *
 * @schema StoreDetail
 */
export interface StoreDetail {
  /**
   * Human-readable label that identifies the data store.
   *
   * @schema StoreDetail#Name
   */
  readonly name?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#Provider
   */
  readonly provider?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#Region
   */
  readonly region?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#Bucket
   */
  readonly bucket?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#Prefix
   */
  readonly prefix?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#Delimiter
   */
  readonly delimiter?: string;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#IncludeTags
   */
  readonly includeTags?: boolean;

  /**
   * Human-readable label that identifies the Federated Database to update.
   *
   * @schema StoreDetail#AdditionalStorageClasses
   */
  readonly additionalStorageClasses?: string[];

}

/**
 * Converts an object of type 'StoreDetail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreDetail(obj: StoreDetail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Name': obj.name,
    'Provider': obj.provider,
    'Region': obj.region,
    'Bucket': obj.bucket,
    'Prefix': obj.prefix,
    'Delimiter': obj.delimiter,
    'IncludeTags': obj.includeTags,
    'AdditionalStorageClasses': obj.additionalStorageClasses?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeDatabaseCollectionView
 */
export interface DataLakeDatabaseCollectionView {
  /**
   * Array that contains the data stores that map to a collection for this data lake.
   *
   * @schema DataLakeDatabaseCollectionView#DataSources
   */
  readonly dataSources?: DataLakeDatabaseDataSourceView[];

  /**
   * Human-readable label that identifies the collection to which MongoDB Cloud maps the data in the data stores.
   *
   * @schema DataLakeDatabaseCollectionView#Name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DataLakeDatabaseCollectionView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeDatabaseCollectionView(obj: DataLakeDatabaseCollectionView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'DataSources': obj.dataSources?.map(y => toJson_DataLakeDatabaseDataSourceView(y)),
    'Name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeViewView
 */
export interface DataLakeViewView {
  /**
   * Human-readable label that identifies the view, which corresponds to an aggregation pipeline on a collection.
   *
   * @schema DataLakeViewView#Name
   */
  readonly name?: string;

  /**
   * Aggregation pipeline stages to apply to the source collection.
   *
   * @schema DataLakeViewView#Pipeline
   */
  readonly pipeline?: string;

  /**
   * Human-readable label that identifies the source collection for the view.
   *
   * @schema DataLakeViewView#Source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'DataLakeViewView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeViewView(obj: DataLakeViewView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Name': obj.name,
    'Pipeline': obj.pipeline,
    'Source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeDatabaseDataSourceView
 */
export interface DataLakeDatabaseDataSourceView {
  /**
   * Flag that validates the scheme in the specified URLs. If `true`, allows insecure `HTTP` scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If `false`, allows secure `HTTPS` scheme only.
   *
   * @schema DataLakeDatabaseDataSourceView#AllowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * Human-readable label that identifies the collection in the database. For creating a wildcard (`*`) collection, you must omit this parameter.
   *
   * @schema DataLakeDatabaseDataSourceView#Collection
   */
  readonly collection?: string;

  /**
   * Regex pattern to use for creating the wildcard (*) collection. To learn more about the regex syntax, see [Go programming language](https://pkg.go.dev/regexp).
   *
   * @schema DataLakeDatabaseDataSourceView#CollectionRegex
   */
  readonly collectionRegex?: string;

  /**
   * Human-readable label that identifies the database, which contains the collection in the cluster. You must omit this parameter to generate wildcard (`*`) collections for dynamically generated databases.
   *
   * @schema DataLakeDatabaseDataSourceView#Database
   */
  readonly database?: string;

  /**
   * File format that MongoDB Cloud uses if it encounters a file without a file extension while searching **storeName**.
   *
   * @schema DataLakeDatabaseDataSourceView#DefaultFormat
   */
  readonly defaultFormat?: DataLakeDatabaseDataSourceViewDefaultFormat;

  /**
   * File path that controls how MongoDB Cloud searches for and parses files in the **storeName** before mapping them to a collection.Specify ``/`` to capture all files and folders from the ``prefix`` path.
   *
   * @schema DataLakeDatabaseDataSourceView#Path
   */
  readonly path?: string;

  /**
   * Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
   *
   * @schema DataLakeDatabaseDataSourceView#StoreName
   */
  readonly storeName?: string;

  /**
   * URLs of the publicly accessible data files. You can't specify URLs that require authentication. Atlas Data Lake creates a partition for each URL. If empty or omitted, Data Lake uses the URLs from the store specified in the **dataSources.storeName** parameter.
   *
   * @schema DataLakeDatabaseDataSourceView#Urls
   */
  readonly urls?: string[];

}

/**
 * Converts an object of type 'DataLakeDatabaseDataSourceView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeDatabaseDataSourceView(obj: DataLakeDatabaseDataSourceView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'AllowInsecure': obj.allowInsecure,
    'Collection': obj.collection,
    'CollectionRegex': obj.collectionRegex,
    'Database': obj.database,
    'DefaultFormat': obj.defaultFormat,
    'Path': obj.path,
    'StoreName': obj.storeName,
    'Urls': obj.urls?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * File format that MongoDB Cloud uses if it encounters a file without a file extension while searching **storeName**.
 *
 * @schema DataLakeDatabaseDataSourceViewDefaultFormat
 */
export enum DataLakeDatabaseDataSourceViewDefaultFormat {
  /** .avro */
  AVRO = ".avro",
  /** .avro.gz */
  AVRO_GZ = ".avro.gz",
  /** .bson */
  BSON = ".bson",
  /** .bson.gz */
  BSON_GZ = ".bson.gz",
  /** .csv */
  CSV = ".csv",
  /** .json */
  JSON = ".json",
  /** .json.gz */
  JSON_GZ = ".json.gz",
  /** .orc */
  ORC = ".orc",
  /** .tsv */
  TSV = ".tsv",
  /** .tsv.gz */
  TSV_GZ = ".tsv.gz",
}


/**
 * A CloudFormation `MongoDB::Atlas::DataLakes`
 *
 * @cloudformationResource MongoDB::Atlas::DataLakes
 * @stability external
 * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
 */
export class CfnDataLakes extends cdk.CfnResource {
  /**
  * The CloudFormation resource type name for this resource class.
  */
  public static readonly CFN_RESOURCE_TYPE_NAME = "MongoDB::Atlas::DataLakes";

  /**
   * Resource props.
   */
  public readonly props: CfnDataLakesProps;

  /**
   * Attribute `MongoDB::Atlas::DataLakes.GroupId`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrGroupId: string;
  /**
   * Attribute `MongoDB::Atlas::DataLakes.TenantName`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrTenantName: string;
  /**
   * Attribute `MongoDB::Atlas::DataLakes.SkipRoleValidation`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrSkipRoleValidation: cdk.IResolvable;
  /**
   * Attribute `MongoDB::Atlas::DataLakes.StartDate`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrStartDate: number;
  /**
   * Attribute `MongoDB::Atlas::DataLakes.Hostnames`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrHostnames: string[];
  /**
   * Attribute `MongoDB::Atlas::DataLakes.State`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrState: string;
  /**
   * Attribute `MongoDB::Atlas::DataLakes.EndDate`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrEndDate: number;

  /**
   * Create a new `MongoDB::Atlas::DataLakes`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(scope: constructs.Construct, id: string, props: CfnDataLakesProps) {
    super(scope, id, { type: CfnDataLakes.CFN_RESOURCE_TYPE_NAME, properties: toJson_CfnDataLakesProps(props)! });

    this.props = props;

    this.attrGroupId = cdk.Token.asString(this.getAtt('GroupId'));
    this.attrTenantName = cdk.Token.asString(this.getAtt('TenantName'));
    this.attrSkipRoleValidation = this.getAtt('SkipRoleValidation');
    this.attrStartDate = cdk.Token.asNumber(this.getAtt('StartDate'));
    this.attrHostnames = cdk.Token.asList(this.getAtt('Hostnames'));
    this.attrState = cdk.Token.asString(this.getAtt('State'));
    this.attrEndDate = cdk.Token.asNumber(this.getAtt('EndDate'));
  }
}