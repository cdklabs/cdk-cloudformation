// Generated by cdk-import
import * as cdk from 'aws-cdk-lib';
import * as constructs from 'constructs';

/**
 * View and manage your application's [triggers](https://www.mongodb.com/docs/atlas/app-services/triggers/overview/).
 *
 * @schema CfnTriggerProps
 */
export interface CfnTriggerProps {
  /**
   * @schema CfnTriggerProps#RealmConfig
   */
  readonly realmConfig?: RealmConfig;

  /**
   * @schema CfnTriggerProps#DatabaseTrigger
   */
  readonly databaseTrigger?: DatabaseConfig;

  /**
   * @schema CfnTriggerProps#AuthTrigger
   */
  readonly authTrigger?: AuthConfig;

  /**
   * @schema CfnTriggerProps#ScheduleTrigger
   */
  readonly scheduleTrigger?: ScheduleConfig;

  /**
   * The trigger's name.
   *
   * @schema CfnTriggerProps#Name
   */
  readonly name?: string;

  /**
   * The trigger's type.
   *
   * @schema CfnTriggerProps#Type
   */
  readonly type?: string;

  /**
   * If `true`, the trigger is disabled and does not listen for events or execute.
   *
   * @schema CfnTriggerProps#Disabled
   */
  readonly disabled?: boolean;

  /**
   * The ID of the function that the trigger calls when it fires.
   *
   * This value is the same as `event_processors.FUNCTION.function_id`.
   * You can either define the value here or in `event_processors.FUNCTION.function_id`.
   * The App Services backend duplicates the value to the configuration location where you did not define it.
   *
   * For example, if you define `function_id`, the backend duplicates it to `event_processors.FUNCTION.function_id`.
   *
   * @schema CfnTriggerProps#FunctionId
   */
  readonly functionId?: string;

  /**
   * The name of the function that the trigger calls when it
   * fires, i.e. the function described by `function_id`.
   *
   * This value is the same as `event_processors.FUNCTION.function_name`.
   * You can either define the value here or in `event_processors.FUNCTION.function_name`.
   * The App Services backend duplicates the value to the configuration location where you did not define it.
   *
   * For example, if you define `function_name`, the backend duplicates it to `event_processors.FUNCTION.function_name`.
   *
   * @schema CfnTriggerProps#FunctionName
   */
  readonly functionName?: string;

  /**
   * An object where each field name is an event processor ID and
   * each value is an object that configures its corresponding
   * event processor. For an example configuration object, see
   * [Send Trigger Events to AWS
   * EventBridge](https://www.mongodb.com/docs/realm/triggers/examples/send-events-aws-eventbridge#std-label-event_processor_example).
   *
   * @schema CfnTriggerProps#EventProcessors
   */
  readonly eventProcessors?: Event;

  /**
   * App Services Application ID
   *
   * @schema CfnTriggerProps#AppId
   */
  readonly appId: string;

  /**
   * Project Id for application services
   *
   * @schema CfnTriggerProps#ProjectId
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'CfnTriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnTriggerProps(obj: CfnTriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'RealmConfig': toJson_RealmConfig(obj.realmConfig),
    'DatabaseTrigger': toJson_DatabaseConfig(obj.databaseTrigger),
    'AuthTrigger': toJson_AuthConfig(obj.authTrigger),
    'ScheduleTrigger': toJson_ScheduleConfig(obj.scheduleTrigger),
    'Name': obj.name,
    'Type': obj.type,
    'Disabled': obj.disabled,
    'FunctionId': obj.functionId,
    'FunctionName': obj.functionName,
    'EventProcessors': toJson_Event(obj.eventProcessors),
    'AppId': obj.appId,
    'ProjectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RealmConfig
 */
export interface RealmConfig {
  /**
   * @schema RealmConfig#PrivateKey
   */
  readonly privateKey?: string;

  /**
   * @schema RealmConfig#PublicKey
   */
  readonly publicKey?: string;

  /**
   * @schema RealmConfig#BaseURL
   */
  readonly baseUrl?: string;

  /**
   * @schema RealmConfig#RealmBaseURL
   */
  readonly realmBaseUrl?: string;

}

/**
 * Converts an object of type 'RealmConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealmConfig(obj: RealmConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'PrivateKey': obj.privateKey,
    'PublicKey': obj.publicKey,
    'BaseURL': obj.baseUrl,
    'RealmBaseURL': obj.realmBaseUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseConfig
 */
export interface DatabaseConfig {
  /**
   * The _id value of a linked MongoDB data source.
   *
   * See [Get a Data Source](#operation/adminGetService).
   *
   *
   * @schema DatabaseConfig#ServiceId
   */
  readonly serviceId?: string;

  /**
   * The name of a database in the linked data source.
   *
   * @schema DatabaseConfig#Database
   */
  readonly database?: string;

  /**
   * The name of a collection in the specified database. The
   * trigger listens to events from this collection.
   *
   * @schema DatabaseConfig#Collection
   */
  readonly collection?: string;

  /**
   * The type(s) of MongoDB change event that the trigger listens for.
   *
   * @schema DatabaseConfig#OperationTypes
   */
  readonly operationTypes?: DatabaseConfigOperationTypes[];

  /**
   * A [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match)
   * expression filters change events. The trigger will only
   * fire if the expression evaluates to true for a given
   * change event.
   *
   * @schema DatabaseConfig#Match
   */
  readonly match?: any;

  /**
   * If `true`, indicates that `UPDATE` change events should
   * include the most current
   * [majority-committed](https://www.mongodb.com/docs/manual/reference/read-concern-majority/)
   * version of the modified document in the `fullDocument`
   * field.
   *
   * @schema DatabaseConfig#FullDocument
   */
  readonly fullDocument?: boolean;

  /**
   * If true, indicates that `UPDATE` change events should
   * include a snapshot of the modified document from
   * immediately before the update was applied.
   *
   * You must enable [document
   * preimages](https://www.mongodb.com/docs/atlas/app-services/mongodb/preimages/)
   * for your cluster to include these snapshots.
   *
   * @schema DatabaseConfig#FullDocumentBeforeChange
   */
  readonly fullDocumentBeforeChange?: boolean;

  /**
   * If `true`, enabling the Trigger after it was disabled
   * will not invoke events that occurred while the Trigger
   * was disabled.
   *
   * @schema DatabaseConfig#SkipCatchupEvents
   */
  readonly skipCatchupEvents?: boolean;

  /**
   * If `true`, when this Trigger's resume token
   * cannot be found in the cluster's oplog, the Trigger automatically resumes
   * processing events at the next relevant change stream event.
   * All change stream events from when the Trigger was suspended until the Trigger
   * resumes execution do not have the Trigger fire for them.
   *
   * @schema DatabaseConfig#TolerateResumeErrors
   */
  readonly tolerateResumeErrors?: boolean;

  /**
   * If `true`, event ordering is disabled and this Trigger
   * can process events in parallel. If `false`, event
   * ordering is enabled and the Trigger executes events
   * serially.
   *
   * @schema DatabaseConfig#Unordered
   */
  readonly unordered?: boolean;

}

/**
 * Converts an object of type 'DatabaseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseConfig(obj: DatabaseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ServiceId': obj.serviceId,
    'Database': obj.database,
    'Collection': obj.collection,
    'OperationTypes': obj.operationTypes?.map(y => y),
    'Match': obj.match,
    'FullDocument': obj.fullDocument,
    'FullDocumentBeforeChange': obj.fullDocumentBeforeChange,
    'SkipCatchupEvents': obj.skipCatchupEvents,
    'TolerateResumeErrors': obj.tolerateResumeErrors,
    'Unordered': obj.unordered,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AuthConfig
 */
export interface AuthConfig {
  /**
   * The type of authentication event that the trigger listens for.
   *
   * @schema AuthConfig#OperationType
   */
  readonly operationType: AuthConfigOperationType;

  /**
   * The type(s) of authentication provider that the trigger listens to.
   *
   * @schema AuthConfig#Providers
   */
  readonly providers: AuthConfigProviders[];

}

/**
 * Converts an object of type 'AuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthConfig(obj: AuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'OperationType': obj.operationType,
    'Providers': obj.providers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleConfig
 */
export interface ScheduleConfig {
  /**
   * A [cron expression](https://www.mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/#cron-expressions) that specifies when the trigger executes.
   *
   * @schema ScheduleConfig#Schedule
   */
  readonly schedule?: string;

  /**
   * If `true`, enabling the trigger after it was disabled
   * will not invoke events that occurred while the trigger
   * was disabled.
   *
   * @schema ScheduleConfig#SkipcatchupEvents
   */
  readonly skipcatchupEvents?: boolean;

}

/**
 * Converts an object of type 'ScheduleConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleConfig(obj: ScheduleConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Schedule': obj.schedule,
    'SkipcatchupEvents': obj.skipcatchupEvents,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Event
 */
export interface Event {
  /**
   * @schema Event#FUNCTION
   */
  readonly function?: EventFunction;

  /**
   * @schema Event#AWSEVENTBRIDGE
   */
  readonly awseventbridge?: EventAwseventbridge;

}

/**
 * Converts an object of type 'Event' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Event(obj: Event | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'FUNCTION': toJson_EventFunction(obj.function),
    'AWSEVENTBRIDGE': toJson_EventAwseventbridge(obj.awseventbridge),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseConfigOperationTypes
 */
export enum DatabaseConfigOperationTypes {
  /** INSERT */
  INSERT = "INSERT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** REPLACE */
  REPLACE = "REPLACE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * The type of authentication event that the trigger listens for.
 *
 * @schema AuthConfigOperationType
 */
export enum AuthConfigOperationType {
  /** LOGIN */
  LOGIN = "LOGIN",
  /** CREATE */
  CREATE = "CREATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * @schema AuthConfigProviders
 */
export enum AuthConfigProviders {
  /** anon-user */
  ANON_USER = "anon-user",
  /** api-key */
  API_KEY = "api-key",
  /** custom-token */
  CUSTOM_TOKEN = "custom-token",
  /** custom-function */
  CUSTOM_FUNCTION = "custom-function",
  /** local-userpass */
  LOCAL_USERPASS = "local-userpass",
  /** oauth2-apple */
  OAUTH2_APPLE = "oauth2-apple",
  /** oauth2-facebook */
  OAUTH2_FACEBOOK = "oauth2-facebook",
  /** oauth2-google */
  OAUTH2_GOOGLE = "oauth2-google",
}

/**
 * @schema EventFunction
 */
export interface EventFunction {
  /**
   * @schema EventFunction#FuncConfig
   */
  readonly funcConfig?: EventFunctionFuncConfig;

}

/**
 * Converts an object of type 'EventFunction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventFunction(obj: EventFunction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'FuncConfig': toJson_EventFunctionFuncConfig(obj.funcConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventAwseventbridge
 */
export interface EventAwseventbridge {
  /**
   * @schema EventAwseventbridge#AWSConfig
   */
  readonly awsConfig?: EventAwseventbridgeAwsConfig;

}

/**
 * Converts an object of type 'EventAwseventbridge' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventAwseventbridge(obj: EventAwseventbridge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'AWSConfig': toJson_EventAwseventbridgeAwsConfig(obj.awsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventFunctionFuncConfig
 */
export interface EventFunctionFuncConfig {
  /**
   * The ID of the function that the trigger calls when it fires.
   *
   * This value is the same as the root-level `function_id`.
   * You can either define the value here or in `function_id`.
   * The App Services backend duplicates the value to the configuration location where you did not define it.
   *
   * For example, if you define `event_processors.FUNCTION.function_id`, the backend duplicates it to `function_id`.
   *
   * @schema EventFunctionFuncConfig#FunctionId
   */
  readonly functionId?: string;

  /**
   * The name of the function that the trigger calls when it
   * fires, i.e. the function described by `function_id`.
   *
   * This value is the same as the root-level `function_name`.
   * You can either define the value here or in `function_name`.
   * The App Services backend duplicates the value to the configuration location where you did not define it.
   *
   * For example, if you define `event_processors.FUNCTION.function_name`, the backend duplicates it to `function_name`.
   *
   * @schema EventFunctionFuncConfig#FunctionName
   */
  readonly functionName?: string;

}

/**
 * Converts an object of type 'EventFunctionFuncConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventFunctionFuncConfig(obj: EventFunctionFuncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'FunctionId': obj.functionId,
    'FunctionName': obj.functionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventAwseventbridgeAwsConfig
 */
export interface EventAwseventbridgeAwsConfig {
  /**
   * An AWS Account ID.
   *
   * @schema EventAwseventbridgeAwsConfig#AccountId
   */
  readonly accountId?: string;

  /**
   * An AWS region.
   *
   * @schema EventAwseventbridgeAwsConfig#Region
   */
  readonly region?: string;

  /**
   * If `true`, event objects are serialized using EJSON.
   *
   * @schema EventAwseventbridgeAwsConfig#ExtendedJsonEnabled
   */
  readonly extendedJsonEnabled?: boolean;

}

/**
 * Converts an object of type 'EventAwseventbridgeAwsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventAwseventbridgeAwsConfig(obj: EventAwseventbridgeAwsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'AccountId': obj.accountId,
    'Region': obj.region,
    'ExtendedJsonEnabled': obj.extendedJsonEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A CloudFormation `MongoDB::Atlas::Trigger`
 *
 * @cloudformationResource MongoDB::Atlas::Trigger
 * @stability external
 * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
 */
export class CfnTrigger extends cdk.CfnResource {
  /**
  * The CloudFormation resource type name for this resource class.
  */
  public static readonly CFN_RESOURCE_TYPE_NAME = "MongoDB::Atlas::Trigger";

  /**
   * Resource props.
   */
  public readonly props: CfnTriggerProps;

  /**
   * Attribute `MongoDB::Atlas::Trigger.Id`
   * @link https://github.com/aws-cloudformation/aws-cloudformation-rpdk.git
   */
  public readonly attrId: string;

  /**
   * Create a new `MongoDB::Atlas::Trigger`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(scope: constructs.Construct, id: string, props: CfnTriggerProps) {
    super(scope, id, { type: CfnTrigger.CFN_RESOURCE_TYPE_NAME, properties: toJson_CfnTriggerProps(props)! });

    this.props = props;

    this.attrId = cdk.Token.asString(this.getAtt('Id'));
  }
}