// Generated by cdk-import
import * as cdk from 'aws-cdk-lib';
import * as constructs from 'constructs';

/**
 * A volume is a logical storage unit which provides flexible space for data files, snapshots, and block devices. The NetApp:FSxN custom resource allows you to configure and manage FSX for ONTAP volumes by specifying parameters such as volume name, size, storage efficiency, export policies, and other attributes. To use this resource, you must create the Link module. Once activated, you will need a preview key to consume this resource. Please reach out to Ng-fsx-cloudformation@netapp.com to get the key.
 *
 * @schema CfnVolumeProps
 */
export interface CfnVolumeProps {
  /**
   * The password source for the FSx admin user.
   *
   * @schema CfnVolumeProps#FsxAdminPasswordSource
   */
  readonly fsxAdminPasswordSource: PasswordSource;

  /**
   * The file system ID of the Amazon FSx for NetApp ONTAP file system in which the resource is created.
   *
   * @schema CfnVolumeProps#FileSystemId
   */
  readonly fileSystemId: string;

  /**
   * The ARN of the AWS Lambda function that will be invoked to manage the resource.
   *
   * @schema CfnVolumeProps#LinkArn
   */
  readonly linkArn: string;

  /**
   * The SVM that contains the volume.
   *
   * @schema CfnVolumeProps#SVM
   */
  readonly svm: NameWithUuidRef;

  /**
   * Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM.
   *
   * @schema CfnVolumeProps#Name
   */
  readonly name: string;

  /**
   * Physical size of the volume, in bytes. The minimum size for a FlexVol volume is 20MB and the minimum size for a FlexGroup volume is 200MB per constituent. The recommended size for a FlexGroup volume is a minimum of 100GB per constituent. For all volumes, the default size is equal to the minimum size.
   *
   * @schema CfnVolumeProps#Size
   */
  readonly size?: number;

  /**
   * Tags associated with the ONTAP volume.
   *
   * @schema CfnVolumeProps#ONTAPTags
   */
  readonly ontapTags?: OntapTag[];

  /**
   * List of aggregate names that host the volume.
   *
   * @schema CfnVolumeProps#Aggregates
   */
  readonly aggregates?: string[];

  /**
   * Specifies the number of times to iterate constituents over the aggregates when creating or expanding a FlexGroup volume.
   *
   * @schema CfnVolumeProps#ConstituentsPerAggregate
   */
  readonly constituentsPerAggregate?: number;

  /**
   * Snapshot policy name.
   *
   * @schema CfnVolumeProps#SnapshotPolicy
   */
  readonly snapshotPolicy?: string;

  /**
   * Indicates if the volume is encrypted.
   *
   * @schema CfnVolumeProps#Encryption
   */
  readonly encryption?: boolean;

  /**
   * The type of volume (e.g., read-write or data protection).
   *
   * @schema CfnVolumeProps#Type
   */
  readonly type?: CfnVolumePropsType;

  /**
   * The style of the volume (e.g., FlexVol or FlexGroup).
   *
   * @schema CfnVolumeProps#Style
   */
  readonly style?: CfnVolumePropsStyle;

  /**
   * The state of the volume (e.g., online, offline, restricted). Client access is supported only when volume is online and connected to its junction path. Taking volume to offline or restricted state removes its junction path and blocks client access.
   *
   * @schema CfnVolumeProps#State
   */
  readonly state?: CfnVolumePropsState;

  /**
   * The anti-ransomware state of the volume.
   *
   * @schema CfnVolumeProps#AntiRansomwareState
   */
  readonly antiRansomwareState?: CfnVolumePropsAntiRansomwareState;

  /**
   * The storage efficiency settings for the volume.
   *
   * @schema CfnVolumeProps#Efficiency
   */
  readonly efficiency?: Efficiency;

  /**
   * The SnapLock settings of the volume.
   *
   * @schema CfnVolumeProps#Snaplock
   */
  readonly snaplock?: Snaplock;

  /**
   * The tiering settings of the volume.
   *
   * @schema CfnVolumeProps#Tiering
   */
  readonly tiering?: Tiering;

  /**
   * The clone settings of the volume.
   *
   * @schema CfnVolumeProps#Clone
   */
  readonly clone?: Clone;

  /**
   * The NAS settings of the volume.
   *
   * @schema CfnVolumeProps#NAS
   */
  readonly nas?: Nas;

  /**
   * The autosize settings of the volume.
   *
   * @schema CfnVolumeProps#Autosize
   */
  readonly autosize?: Autosize;
}

/**
 * Converts an object of type 'CfnVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CfnVolumeProps(obj: CfnVolumeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'FsxAdminPasswordSource': toJson_PasswordSource(obj.fsxAdminPasswordSource),
    'FileSystemId': obj.fileSystemId,
    'LinkArn': obj.linkArn,
    'SVM': toJson_NameWithUuidRef(obj.svm),
    'Name': obj.name,
    'Size': obj.size,
    'ONTAPTags': obj.ontapTags?.map(y => toJson_OntapTag(y)),
    'Aggregates': obj.aggregates?.map(y => y),
    'ConstituentsPerAggregate': obj.constituentsPerAggregate,
    'SnapshotPolicy': obj.snapshotPolicy,
    'Encryption': obj.encryption,
    'Type': obj.type,
    'Style': obj.style,
    'State': obj.state,
    'AntiRansomwareState': obj.antiRansomwareState,
    'Efficiency': toJson_Efficiency(obj.efficiency),
    'Snaplock': toJson_Snaplock(obj.snaplock),
    'Tiering': toJson_Tiering(obj.tiering),
    'Clone': toJson_Clone(obj.clone),
    'NAS': toJson_Nas(obj.nas),
    'Autosize': toJson_Autosize(obj.autosize),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PasswordSource
 */
export interface PasswordSource {
  /**
   * A reference to the source of the password, typically an AWS Secrets Manager secret.
   *
   * @schema PasswordSource#Secret
   */
  readonly secret: SecretSource;
}

/**
 * Converts an object of type 'PasswordSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PasswordSource(obj: PasswordSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Secret': toJson_SecretSource(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NameWithUuidRef
 */
export interface NameWithUuidRef {
  /**
   * The name part of the reference, which can be used to identify resources such as SVM, volume or snapshot.
   *
   * @schema NameWithUuidRef#Name
   */
  readonly name?: string;

  /**
   * The UUID part of the reference, which can be used to identify resources such as SVM, volume or snapshot.
   *
   * @schema NameWithUuidRef#UUID
   */
  readonly uuid?: string;
}

/**
 * Converts an object of type 'NameWithUuidRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NameWithUuidRef(obj: NameWithUuidRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Name': obj.name,
    'UUID': obj.uuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ONTAPTag
 */
export interface OntapTag {
  /**
   * The key of the tag.
   *
   * @schema ONTAPTag#Key
   */
  readonly key: string;

  /**
   * The value of the tag.
   *
   * @schema ONTAPTag#Value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'OntapTag' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OntapTag(obj: OntapTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Key': obj.key,
    'Value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of volume (e.g., read-write or data protection).
 *
 * @schema CfnVolumePropsType
 */
export enum CfnVolumePropsType {
  /** rw */
  RW = "rw",
  /** dp */
  DP = "dp",
}

/**
 * The style of the volume (e.g., FlexVol or FlexGroup).
 *
 * @schema CfnVolumePropsStyle
 */
export enum CfnVolumePropsStyle {
  /** flexvol */
  FLEXVOL = "flexvol",
  /** flexgroup */
  FLEXGROUP = "flexgroup",
}

/**
 * The state of the volume (e.g., online, offline, restricted). Client access is supported only when volume is online and connected to its junction path. Taking volume to offline or restricted state removes its junction path and blocks client access.
 *
 * @schema CfnVolumePropsState
 */
export enum CfnVolumePropsState {
  /** offline */
  OFFLINE = "offline",
  /** online */
  ONLINE = "online",
  /** restricted */
  RESTRICTED = "restricted",
}

/**
 * The anti-ransomware state of the volume.
 *
 * @schema CfnVolumePropsAntiRansomwareState
 */
export enum CfnVolumePropsAntiRansomwareState {
  /** disabled */
  DISABLED = "disabled",
  /** dry_run */
  DRY_UNDERSCORE_RUN = "dry_run",
  /** enabled */
  ENABLED = "enabled",
  /** paused */
  PAUSED = "paused",
}

/**
 * @schema Efficiency
 */
export interface Efficiency {
  /**
   * The compaction setting of the volume.
   *
   * @schema Efficiency#Compaction
   */
  readonly compaction?: EfficiencyCompaction;

  /**
   * The compression setting of the volume.
   *
   * @schema Efficiency#Compression
   */
  readonly compression?: EfficiencyCompression;

  /**
   * The deduplication setting of the volume.
   *
   * @schema Efficiency#Dedupe
   */
  readonly dedupe?: EfficiencyDedupe;

  /**
   * The cross-volume deduplication setting of the volume.
   *
   * @schema Efficiency#CrossVolumeDedupe
   */
  readonly crossVolumeDedupe?: EfficiencyCrossVolumeDedupe;
}

/**
 * Converts an object of type 'Efficiency' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Efficiency(obj: Efficiency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Compaction': obj.compaction,
    'Compression': obj.compression,
    'Dedupe': obj.dedupe,
    'CrossVolumeDedupe': obj.crossVolumeDedupe,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema Snaplock
 */
export interface Snaplock {
  /**
   * The SnapLock type of the volume.
   *
   * @schema Snaplock#SnaplockType
   */
  readonly snaplockType?: SnaplockSnaplockType;

  /**
   * The minimum retention period for the SnapLock volume.
   *
   * @schema Snaplock#MinimumRetention
   */
  readonly minimumRetention?: string;

  /**
   * The maximum retention period for the SnapLock volume.
   *
   * @schema Snaplock#MaximumRetention
   */
  readonly maximumRetention?: string;

  /**
   * The default retention period for new files in the SnapLock volume.
   *
   * @schema Snaplock#DefaultRetention
   */
  readonly defaultRetention?: string;
}

/**
 * Converts an object of type 'Snaplock' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Snaplock(obj: Snaplock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SnaplockType': obj.snaplockType,
    'MinimumRetention': obj.minimumRetention,
    'MaximumRetention': obj.maximumRetention,
    'DefaultRetention': obj.defaultRetention,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema Tiering
 */
export interface Tiering {
  /**
   * Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the capacity pool storage tier when they become cold.
   *
   * @schema Tiering#Policy
   */
  readonly policy: TieringPolicy;

  /**
   * This parameter specifies the minimum number of days that user data blocks of the volume must be cooled before they can be considered cold and tiered out to the capacity pool storage tier.
   *
   * @schema Tiering#MinCoolingDays
   */
  readonly minCoolingDays?: number;
}

/**
 * Converts an object of type 'Tiering' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Tiering(obj: Tiering | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Policy': obj.policy,
    'MinCoolingDays': obj.minCoolingDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema Clone
 */
export interface Clone {
  /**
   * SVM containing the parent volume.
   *
   * @schema Clone#ParentSVM
   */
  readonly parentSvm: NameWithUuidRef;

  /**
   * The parent volume of the clone.
   *
   * @schema Clone#ParentVolume
   */
  readonly parentVolume: NameWithUuidRef;

  /**
   * The snapshot of the parent volume from which the clone is created.
   *
   * @schema Clone#ParentSnapshot
   */
  readonly parentSnapshot?: NameWithUuidRef;

  /**
   * Setting 'IsCloned' attribute to false splits the clone from its parent volume.
   *
   * @schema Clone#IsCloned
   */
  readonly isCloned?: boolean;
}

/**
 * Converts an object of type 'Clone' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Clone(obj: Clone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ParentSVM': toJson_NameWithUuidRef(obj.parentSvm),
    'ParentVolume': toJson_NameWithUuidRef(obj.parentVolume),
    'ParentSnapshot': toJson_NameWithUuidRef(obj.parentSnapshot),
    'IsCloned': obj.isCloned,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NAS
 */
export interface Nas {
  /**
   * Security style associated with the volume.
   *
   * @schema NAS#SecurityStyle
   */
  readonly securityStyle?: NasSecurityStyle;

  /**
   * The fully-qualified path in the hosting SVM's namespace at which the volume is mounted.
   *
   * @schema NAS#JunctionPath
   */
  readonly junctionPath?: string;

  /**
   * The export policy associated with the volume.
   *
   * @schema NAS#ExportPolicy
   */
  readonly exportPolicy?: string;
}

/**
 * Converts an object of type 'Nas' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Nas(obj: Nas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecurityStyle': obj.securityStyle,
    'JunctionPath': obj.junctionPath,
    'ExportPolicy': obj.exportPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema Autosize
 */
export interface Autosize {
  /**
   * The autosize mode of the volume.
   *
   * @schema Autosize#Mode
   */
  readonly mode?: AutosizeMode;

  /**
   * Minimum size in bytes up to which the volume shrinks automatically. This size cannot be greater than or equal to the maximum size of volume.
   *
   * @schema Autosize#Minimum
   */
  readonly minimum?: number;

  /**
   * Maximum size in bytes up to which a volume grows automatically. This size cannot be less than the current volume size, or less than or equal to the minimum size of volume.
   *
   * @schema Autosize#Maximum
   */
  readonly maximum?: number;

  /**
   * The used space threshold percentage for automatic growth of the volume.
   *
   * @schema Autosize#GrowThreshold
   */
  readonly growThreshold?: number;

  /**
   * The used space threshold percentage for automatic shrinkage of the volume.
   *
   * @schema Autosize#ShrinkThreshold
   */
  readonly shrinkThreshold?: number;
}

/**
 * Converts an object of type 'Autosize' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Autosize(obj: Autosize | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Mode': obj.mode,
    'Minimum': obj.minimum,
    'Maximum': obj.maximum,
    'GrowThreshold': obj.growThreshold,
    'ShrinkThreshold': obj.shrinkThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretSource
 */
export interface SecretSource {
  /**
   * The ARN of the secret stored in AWS Secrets Manager.
   *
   * @schema SecretSource#SecretArn
   */
  readonly secretArn: string;

  /**
   * Reference for the SecretKey. The actual password is stored in AWS Secret Manager.
   *
   * @schema SecretSource#SecretKey
   */
  readonly secretKey: string;
}

/**
 * Converts an object of type 'SecretSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretSource(obj: SecretSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretArn': obj.secretArn,
    'SecretKey': obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The compaction setting of the volume.
 *
 * @schema EfficiencyCompaction
 */
export enum EfficiencyCompaction {
  /** inline */
  INLINE = "inline",
  /** none */
  NONE = "none",
  /** mixed */
  MIXED = "mixed",
}

/**
 * The compression setting of the volume.
 *
 * @schema EfficiencyCompression
 */
export enum EfficiencyCompression {
  /** inline */
  INLINE = "inline",
  /** background */
  BACKGROUND = "background",
  /** both */
  BOTH = "both",
  /** none */
  NONE = "none",
  /** mixed */
  MIXED = "mixed",
}

/**
 * The deduplication setting of the volume.
 *
 * @schema EfficiencyDedupe
 */
export enum EfficiencyDedupe {
  /** inline */
  INLINE = "inline",
  /** background */
  BACKGROUND = "background",
  /** both */
  BOTH = "both",
  /** none */
  NONE = "none",
  /** mixed */
  MIXED = "mixed",
}

/**
 * The cross-volume deduplication setting of the volume.
 *
 * @schema EfficiencyCrossVolumeDedupe
 */
export enum EfficiencyCrossVolumeDedupe {
  /** inline */
  INLINE = "inline",
  /** background */
  BACKGROUND = "background",
  /** both */
  BOTH = "both",
  /** none */
  NONE = "none",
  /** mixed */
  MIXED = "mixed",
}

/**
 * The SnapLock type of the volume.
 *
 * @schema SnaplockSnaplockType
 */
export enum SnaplockSnaplockType {
  /** compliance */
  COMPLIANCE = "compliance",
  /** enterprise */
  ENTERPRISE = "enterprise",
  /** non_snaplock */
  NON_UNDERSCORE_SNAPLOCK = "non_snaplock",
}

/**
 * Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the capacity pool storage tier when they become cold.
 *
 * @schema TieringPolicy
 */
export enum TieringPolicy {
  /** all */
  ALL = "all",
  /** auto */
  AUTO = "auto",
  /** none */
  NONE = "none",
  /** snapshot_only */
  SNAPSHOT_UNDERSCORE_ONLY = "snapshot_only",
}

/**
 * Security style associated with the volume.
 *
 * @schema NasSecurityStyle
 */
export enum NasSecurityStyle {
  /** mixed */
  MIXED = "mixed",
  /** ntfs */
  NTFS = "ntfs",
  /** unix */
  UNIX = "unix",
}

/**
 * The autosize mode of the volume.
 *
 * @schema AutosizeMode
 */
export enum AutosizeMode {
  /** grow */
  GROW = "grow",
  /** grow_shrink */
  GROW_UNDERSCORE_SHRINK = "grow_shrink",
  /** off */
  OFF = "off",
}


/**
 * A CloudFormation `NetApp::FSxN::Volume`
 *
 * @cloudformationResource NetApp::FSxN::Volume
 * @stability external
 * @link https://github.com/NetApp/NetApp-CloudFormation-FSx-ONTAP-provider
 */
export class CfnVolume extends cdk.CfnResource {
  /**
  * The CloudFormation resource type name for this resource class.
  */
  public static readonly CFN_RESOURCE_TYPE_NAME = "NetApp::FSxN::Volume";

  /**
   * Resource props.
   */
  public readonly props: CfnVolumeProps;

  /**
   * Attribute `NetApp::FSxN::Volume.UUID`
   * @link https://github.com/NetApp/NetApp-CloudFormation-FSx-ONTAP-provider
   */
  public readonly attrUuid: string;

  /**
   * Create a new `NetApp::FSxN::Volume`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(scope: constructs.Construct, id: string, props: CfnVolumeProps) {
    super(scope, id, { type: CfnVolume.CFN_RESOURCE_TYPE_NAME, properties: toJson_CfnVolumeProps(props)! });

    this.props = props;

    this.attrUuid = cdk.Token.asString(this.getAtt('UUID'));
  }
}