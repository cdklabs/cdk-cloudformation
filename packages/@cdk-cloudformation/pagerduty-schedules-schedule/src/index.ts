// Generated by cdk-import
import * as cdk from 'aws-cdk-lib';
import * as constructs from 'constructs';

/**
 * Manage a on-call schedule in PagerDuty
 *
 * @schema CfnScheduleProps
 */
export interface CfnScheduleProps {
  /**
   * A list of schedule layers.
   *
   * @schema CfnScheduleProps#ScheduleLayers
   */
  readonly scheduleLayers?: ScheduleLayer[];

  /**
   * The time zone of the schedule.
   *
   * @schema CfnScheduleProps#TimeZone
   */
  readonly timeZone: string;

  /**
   * The name of the schedule.
   *
   * @schema CfnScheduleProps#Name
   */
  readonly name?: string;

  /**
   * The description of the schedule
   *
   * @schema CfnScheduleProps#Description
   */
  readonly description?: string;

  /**
   * @schema CfnScheduleProps#FinalSchedule
   */
  readonly finalSchedule?: SubSchedule;

  /**
   * @schema CfnScheduleProps#OverridesSubschedule
   */
  readonly overridesSubschedule?: SubSchedule;

  /**
   * @schema CfnScheduleProps#Id
   */
  readonly id?: string;

  /**
   * @schema CfnScheduleProps#Summary
   */
  readonly summary?: string;

  /**
   * @schema CfnScheduleProps#Self
   */
  readonly self?: string;

  /**
   * @schema CfnScheduleProps#HtmlUrl
   */
  readonly htmlUrl?: string;

  /**
   * An array of all of the users on the schedule.
   *
   * @schema CfnScheduleProps#Users
   */
  readonly users?: User[];

  /**
   * An array of all of the teams on the schedule.
   *
   * @schema CfnScheduleProps#Teams
   */
  readonly teams?: Team[];

}

/**
 * Converts an object of type 'CfnScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnScheduleProps(obj: CfnScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ScheduleLayers': obj.scheduleLayers?.map(y => toJson_ScheduleLayer(y)),
    'TimeZone': obj.timeZone,
    'Name': obj.name,
    'Description': obj.description,
    'FinalSchedule': toJson_SubSchedule(obj.finalSchedule),
    'OverridesSubschedule': toJson_SubSchedule(obj.overridesSubschedule),
    'Id': obj.id,
    'Summary': obj.summary,
    'Self': obj.self,
    'HtmlUrl': obj.htmlUrl,
    'Users': obj.users?.map(y => toJson_User(y)),
    'Teams': obj.teams?.map(y => toJson_Team(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleLayer
 */
export interface ScheduleLayer {
  /**
   * @schema ScheduleLayer#Id
   */
  readonly id?: string;

  /**
   * The start time of this layer.
   *
   * @schema ScheduleLayer#Start
   */
  readonly start: Date;

  /**
   * The end time of this layer. If null, the layer does not end.
   *
   * @schema ScheduleLayer#End
   */
  readonly end?: Date;

  /**
   * The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
   *
   * @schema ScheduleLayer#Users
   */
  readonly users: UserWrapper[];

  /**
   * An array of restrictions for the layer. A restriction is a limit on which period of the day or week the schedule layer can accept assignments.
   *
   * @schema ScheduleLayer#Restrictions
   */
  readonly restrictions?: Restriction[];

  /**
   * The effective start time of the layer. This can be before the start time of the schedule.
   *
   * @schema ScheduleLayer#RotationVirtualStart
   */
  readonly rotationVirtualStart: Date;

  /**
   * The duration of each on-call shift in seconds.
   *
   * @schema ScheduleLayer#RotationTurnLengthSeconds
   */
  readonly rotationTurnLengthSeconds: number;

  /**
   * The name of the schedule layer.
   *
   * @schema ScheduleLayer#Name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ScheduleLayer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleLayer(obj: ScheduleLayer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Id': obj.id,
    'Start': obj.start?.toISOString(),
    'End': obj.end?.toISOString(),
    'Users': obj.users?.map(y => toJson_UserWrapper(y)),
    'Restrictions': obj.restrictions?.map(y => toJson_Restriction(y)),
    'RotationVirtualStart': obj.rotationVirtualStart?.toISOString(),
    'RotationTurnLengthSeconds': obj.rotationTurnLengthSeconds,
    'Name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubSchedule
 */
export interface SubSchedule {
  /**
   * The name of the subschedule
   *
   * @schema SubSchedule#Name
   */
  readonly name: SubScheduleName;

  /**
   * This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated.
   *
   * @schema SubSchedule#RenderedScheduleEntries
   */
  readonly renderedScheduleEntries?: RenderedScheduleEntries[];

  /**
   * @schema SubSchedule#RenderedCoveragePercentage
   */
  readonly renderedCoveragePercentage?: number;

}

/**
 * Converts an object of type 'SubSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubSchedule(obj: SubSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Name': obj.name,
    'RenderedScheduleEntries': obj.renderedScheduleEntries?.map(y => toJson_RenderedScheduleEntries(y)),
    'RenderedCoveragePercentage': obj.renderedCoveragePercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema User
 */
export interface User {
  /**
   * A string that determines the schema of the object. This must be the standard name for the entity, suffixed by _reference if the object is a reference./, =, +, and -.
   *
   * @schema User#Type
   */
  readonly type: UserType;

  /**
   * @schema User#Id
   */
  readonly id: string;

  /**
   * @schema User#Summary
   */
  readonly summary?: string;

  /**
   * @schema User#HtmlUrl
   */
  readonly htmlUrl?: string;

  /**
   * @schema User#Self
   */
  readonly self?: string;

}

/**
 * Converts an object of type 'User' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_User(obj: User | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Type': obj.type,
    'Id': obj.id,
    'Summary': obj.summary,
    'HtmlUrl': obj.htmlUrl,
    'Self': obj.self,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Team
 */
export interface Team {
  /**
   * A string that determines the schema of the object. This must be the standard name for the entity, suffixed by _reference if the object is a reference./, =, +, and -.
   *
   * @schema Team#Type
   */
  readonly type: TeamType;

  /**
   * @schema Team#Id
   */
  readonly id: string;

  /**
   * @schema Team#Summary
   */
  readonly summary?: string;

  /**
   * @schema Team#HtmlUrl
   */
  readonly htmlUrl?: string;

  /**
   * @schema Team#Self
   */
  readonly self?: string;

}

/**
 * Converts an object of type 'Team' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Team(obj: Team | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Type': obj.type,
    'Id': obj.id,
    'Summary': obj.summary,
    'HtmlUrl': obj.htmlUrl,
    'Self': obj.self,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserWrapper
 */
export interface UserWrapper {
  /**
   * @schema UserWrapper#User
   */
  readonly user: User;

}

/**
 * Converts an object of type 'UserWrapper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserWrapper(obj: UserWrapper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'User': toJson_User(obj.user),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Restriction
 */
export interface Restriction {
  /**
   * Specify the types of restriction.
   *
   * @schema Restriction#Type
   */
  readonly type: RestrictionType;

  /**
   * The duration of the restriction in seconds.
   *
   * @schema Restriction#DurationSeconds
   */
  readonly durationSeconds: number;

  /**
   * The start time in HH:mm:ss format.
   *
   * @schema Restriction#StartTimeOfDay
   */
  readonly startTimeOfDay: string;

  /**
   * Only required for use with a weekly_restriction restriction type. The first day of the weekly rotation schedule as ISO 8601 day (1 is Monday, etc.)
   *
   * @schema Restriction#StartDayOfWeek
   */
  readonly startDayOfWeek?: number;

}

/**
 * Converts an object of type 'Restriction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Restriction(obj: Restriction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Type': obj.type,
    'DurationSeconds': obj.durationSeconds,
    'StartTimeOfDay': obj.startTimeOfDay,
    'StartDayOfWeek': obj.startDayOfWeek,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of the subschedule
 *
 * @schema SubScheduleName
 */
export enum SubScheduleName {
  /** Final Scheduled */
  FINAL_SCHEDULED = "Final Scheduled",
  /** Overrides */
  OVERRIDES = "Overrides",
}

/**
 * @schema RenderedScheduleEntries
 */
export interface RenderedScheduleEntries {
  /**
   * @schema RenderedScheduleEntries#User
   */
  readonly user?: User;

  /**
   * The start time of this entry.
   *
   * @schema RenderedScheduleEntries#Start
   */
  readonly start: Date;

  /**
   * The end time of this entry. If null, the entry does not end.
   *
   * @schema RenderedScheduleEntries#End
   */
  readonly end: Date;

}

/**
 * Converts an object of type 'RenderedScheduleEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RenderedScheduleEntries(obj: RenderedScheduleEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'User': toJson_User(obj.user),
    'Start': obj.start?.toISOString(),
    'End': obj.end?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A string that determines the schema of the object. This must be the standard name for the entity, suffixed by _reference if the object is a reference./, =, +, and -.
 *
 * @schema UserType
 */
export enum UserType {
  /** user_reference */
  USER_REFERENCE = "user_reference",
}

/**
 * A string that determines the schema of the object. This must be the standard name for the entity, suffixed by _reference if the object is a reference./, =, +, and -.
 *
 * @schema TeamType
 */
export enum TeamType {
  /** team_reference */
  TEAM_REFERENCE = "team_reference",
  /** team */
  TEAM = "team",
}

/**
 * Specify the types of restriction.
 *
 * @schema RestrictionType
 */
export enum RestrictionType {
  /** daily_restriction */
  DAILY_RESTRICTION = "daily_restriction",
  /** weekly_restriction */
  WEEKLY_RESTRICTION = "weekly_restriction",
}


/**
 * A CloudFormation `PagerDuty::Schedules::Schedule`
 *
 * @cloudformationResource PagerDuty::Schedules::Schedule
 * @stability external
 * @link https://github.com/aws-ia/cloudformation-pagerduty-resource-providers.git
 */
export class CfnSchedule extends cdk.CfnResource {
  /**
  * The CloudFormation resource type name for this resource class.
  */
  public static readonly CFN_RESOURCE_TYPE_NAME = "PagerDuty::Schedules::Schedule";

  /**
   * Resource props.
   */
  public readonly props: CfnScheduleProps;

  /**
   * Attribute `PagerDuty::Schedules::Schedule.Type`
   * @link https://github.com/aws-ia/cloudformation-pagerduty-resource-providers.git
   */
  public readonly attrType: string;

  /**
   * Create a new `PagerDuty::Schedules::Schedule`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(scope: constructs.Construct, id: string, props: CfnScheduleProps) {
    super(scope, id, { type: CfnSchedule.CFN_RESOURCE_TYPE_NAME, properties: toJson_CfnScheduleProps(props)! });

    this.props = props;

    this.attrType = cdk.Token.asString(this.getAtt('Type'));
  }
}